#!/usr/bin/env ruby

require File.expand_path(File.dirname(__FILE__)+'/../config/environment.rb')
require "rest_client"

require 'optparse'
require 'ostruct'

options = OpenStruct.new
options.days = 1
options.base_url = 'localhost'
options.basic = false

OptionParser.new do |opts|

  opts.banner = "Usage: fill_caches [options] "

  opts.separator ""

  opts.on('--basic', "do a quicker, but incomplete job"){|v| options.basic = true}

  opts.on('--server S', String,
          "which server to visit (mandatory)") {|v| options.base_url = "http://#{v}"}

  opts.on('--days N', Integer,
          "how many days to visit (youngest first), default: #{options.days}") {|v| options.days = v}

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

end.parse!(ARGV)

# require 'ruby-debug'
# Debugger.start
# debugger

$logjam = RestClient::Resource.new options.base_url, :timeout => 60.minutes, :headers => {:accept => "text/html"}

# request younger dates first
dates = ControllerAction.log_data_dates.sort.reverse[0,options.days]

def benchmark(url, headers={})
  $stdout.printf "%-60s", url
  $stdout.flush
  begin
    seconds = Benchmark.realtime { $logjam[url].get(headers) }
    $stdout.puts "#{"%9.2f" % seconds } seconds"
  rescue => e
    $stdout.puts e.to_s
  end
end

durations = ControllerAction.durations.sort_by{|d| -(d.to_i)}
resources = Resource.time_resources + Resource.memory_resources + Resource.call_resources
groupings = Resource.groupings
grouping_functions = Resource.grouping_functions.reject(&:blank?)

if options.basic
  durations = Array(durations.first)
  groupings = [:page, :request]
  grouping_functions = [:avg, :sum]
end

dates.each do |date|
  year, month, day = date.split("-")
  durations.each do |duration|
    resources.each do |resource|
      groupings.each do |grouping|
        grouping_functions.each do |grouping_function|
          benchmark("/#{year}/#{month}/#{day}?duration=#{duration}&resource=#{resource}&grouping=#{grouping}&grouping_function=#{grouping_function}")
        end
      end
    end
  end
end

puts "done!"
